{"ast":null,"code":"// @ts-ignore-start\nimport { Chart } from 'react-chartjs-2';\n\nfunction draw() {\n  const {\n    ctx\n  } = this._chart;\n  const vm = this._view;\n  let {\n    borderWidth\n  } = vm;\n  let left;\n  let right;\n  let top;\n  let bottom;\n  let signX;\n  let signY;\n  let borderSkipped;\n  let radius; // If radius is less than 0 or is large enough to cause drawing errors a max\n  //      radius is imposed. If cornerRadius is not defined set it to 0.\n\n  let {\n    cornerRadius\n  } = this._chart.config.options;\n\n  if (cornerRadius < 0) {\n    cornerRadius = 0;\n  }\n\n  if (typeof cornerRadius === 'undefined') {\n    cornerRadius = 0;\n  }\n\n  if (!vm.horizontal) {\n    // bar\n    left = vm.x - vm.width / 2;\n    right = vm.x + vm.width / 2;\n    top = vm.y;\n    bottom = vm.base;\n    signX = 1;\n    signY = bottom > top ? 1 : -1;\n    borderSkipped = vm.borderSkipped || 'bottom';\n  } else {\n    // horizontal bar\n    left = vm.base;\n    right = vm.x;\n    top = vm.y - vm.height / 2;\n    bottom = vm.y + vm.height / 2;\n    signX = right > left ? 1 : -1;\n    signY = 1;\n    borderSkipped = vm.borderSkipped || 'left';\n  } // Canvas doesn't allow us to stroke inside the width so we can\n  // adjust the sizes to fit if we're setting a stroke on the line\n\n\n  if (borderWidth) {\n    // borderWidth shold be less than bar width and bar height.\n    const barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n    borderWidth = borderWidth > barSize ? barSize : borderWidth;\n    const halfStroke = borderWidth / 2; // Adjust borderWidth when bar top position is near vm.base(zero).\n\n    const borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n    const borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n    const borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n    const borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0); // not become a vertical line?\n\n    if (borderLeft !== borderRight) {\n      top = borderTop;\n      bottom = borderBottom;\n    } // not become a horizontal line?\n\n\n    if (borderTop !== borderBottom) {\n      left = borderLeft;\n      right = borderRight;\n    }\n  }\n\n  ctx.beginPath();\n  ctx.fillStyle = vm.backgroundColor;\n  ctx.strokeStyle = vm.borderColor;\n  ctx.lineWidth = borderWidth; // Corner points, from bottom-left to bottom-right clockwise\n  // | 1 2 |\n  // | 0 3 |\n\n  const corners = [[left, bottom], [left, top], [right, top], [right, bottom]]; // Find first (starting) corner with fallback to 'bottom'\n\n  const borders = ['bottom', 'left', 'top', 'right'];\n  let startCorner = borders.indexOf(borderSkipped, 0);\n\n  if (startCorner === -1) {\n    startCorner = 0;\n  }\n\n  function cornerAt(index) {\n    return corners[(startCorner + index) % 4];\n  } // Draw rectangle from 'startCorner'\n\n\n  let corner = cornerAt(0);\n  ctx.moveTo(corner[0], corner[1]);\n\n  for (let i = 1; i < 4; i += 1) {\n    corner = cornerAt(i);\n    let nextCornerId = i + 1;\n\n    if (nextCornerId === 4) {\n      nextCornerId = 0;\n    }\n\n    const width = corners[2][0] - corners[1][0];\n    const height = corners[0][1] - corners[1][1];\n    const x = corners[1][0];\n    const y = corners[1][1];\n    radius = cornerRadius; // Fix radius being too large\n\n    if (radius > Math.abs(height) / 2) {\n      radius = Math.floor(Math.abs(height) / 2);\n    }\n\n    if (radius > Math.abs(width) / 2) {\n      radius = Math.floor(Math.abs(width) / 2);\n    }\n\n    if (height < 0) {\n      // Negative values in a standard bar chart\n      const xTl = x;\n      const xTr = x + width;\n      const yTl = y + height;\n      const yTr = y + height;\n      const xBl = x;\n      const xBr = x + width;\n      const yBl = y;\n      const yBr = y; // Draw\n\n      ctx.moveTo(xBl + radius, yBl);\n      ctx.lineTo(xBr - radius, yBr);\n      ctx.quadraticCurveTo(xBr, yBr, xBr, yBr - radius);\n      ctx.lineTo(xTr, yTr + radius);\n      ctx.quadraticCurveTo(xTr, yTr, xTr - radius, yTr);\n      ctx.lineTo(xTl + radius, yTl);\n      ctx.quadraticCurveTo(xTl, yTl, xTl, yTl + radius);\n      ctx.lineTo(xBl, yBl - radius);\n      ctx.quadraticCurveTo(xBl, yBl, xBl + radius, yBl);\n    } else if (width < 0) {\n      // Negative values in a horizontal bar chart\n      const xTl = x + width;\n      const xTr = x;\n      const yTl = y;\n      const yTr = y;\n      const xBl = x + width;\n      const xBr = x;\n      const yBl = y + height;\n      const yBr = y + height; // Draw\n\n      ctx.moveTo(xBl + radius, yBl);\n      ctx.lineTo(xBr - radius, yBr);\n      ctx.quadraticCurveTo(xBr, yBr, xBr, yBr - radius);\n      ctx.lineTo(xTr, yTr + radius);\n      ctx.quadraticCurveTo(xTr, yTr, xTr - radius, yTr);\n      ctx.lineTo(xTl + radius, yTl);\n      ctx.quadraticCurveTo(xTl, yTl, xTl, yTl + radius);\n      ctx.lineTo(xBl, yBl - radius);\n      ctx.quadraticCurveTo(xBl, yBl, xBl + radius, yBl);\n    } else {\n      // Positive Value\n      ctx.moveTo(x + radius, y);\n      ctx.lineTo(x + width - radius, y);\n      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n      ctx.lineTo(x + width, y + height - radius);\n      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n      ctx.lineTo(x + radius, y + height);\n      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n      ctx.lineTo(x, y + radius);\n      ctx.quadraticCurveTo(x, y, x + radius, y);\n    }\n  }\n\n  ctx.fill();\n\n  if (borderWidth) {\n    ctx.stroke();\n  }\n}\n\nChart.helpers.extend(Chart.elements.Rectangle.prototype, {\n  draw\n});","map":{"version":3,"sources":["/home/tawfek/cisco.pm/src/utils/chart.js"],"names":["Chart","draw","ctx","_chart","vm","_view","borderWidth","left","right","top","bottom","signX","signY","borderSkipped","radius","cornerRadius","config","options","horizontal","x","width","y","base","height","barSize","Math","min","abs","halfStroke","borderLeft","borderRight","borderTop","borderBottom","beginPath","fillStyle","backgroundColor","strokeStyle","borderColor","lineWidth","corners","borders","startCorner","indexOf","cornerAt","index","corner","moveTo","i","nextCornerId","floor","xTl","xTr","yTl","yTr","xBl","xBr","yBl","yBr","lineTo","quadraticCurveTo","fill","stroke","helpers","extend","elements","Rectangle","prototype"],"mappings":"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","sourcesContent":["// @ts-ignore-start\nimport { Chart } from 'react-chartjs-2';\nfunction draw() {\n  const { ctx } = this._chart;\n  const vm = this._view;\n  let { borderWidth } = vm;\n\n  let left;\n  let right;\n  let top;\n  let bottom;\n  let signX;\n  let signY;\n  let borderSkipped;\n  let radius;\n\n  // If radius is less than 0 or is large enough to cause drawing errors a max\n  //      radius is imposed. If cornerRadius is not defined set it to 0.\n  let { cornerRadius } = this._chart.config.options;\n  if (cornerRadius < 0) {\n    cornerRadius = 0;\n  }\n\n  if (typeof cornerRadius === 'undefined') {\n    cornerRadius = 0;\n  }\n\n  if (!vm.horizontal) {\n    // bar\n    left = vm.x - vm.width / 2;\n    right = vm.x + vm.width / 2;\n    top = vm.y;\n    bottom = vm.base;\n    signX = 1;\n    signY = bottom > top ? 1 : -1;\n    borderSkipped = vm.borderSkipped || 'bottom';\n  } else {\n    // horizontal bar\n    left = vm.base;\n    right = vm.x;\n    top = vm.y - vm.height / 2;\n    bottom = vm.y + vm.height / 2;\n    signX = right > left ? 1 : -1;\n    signY = 1;\n    borderSkipped = vm.borderSkipped || 'left';\n  }\n\n  // Canvas doesn't allow us to stroke inside the width so we can\n  // adjust the sizes to fit if we're setting a stroke on the line\n  if (borderWidth) {\n    // borderWidth shold be less than bar width and bar height.\n    const barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n    borderWidth = borderWidth > barSize ? barSize : borderWidth;\n    const halfStroke = borderWidth / 2;\n    // Adjust borderWidth when bar top position is near vm.base(zero).\n    const borderLeft =\n      left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n    const borderRight =\n      right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n    const borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n    const borderBottom =\n      bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n    // not become a vertical line?\n    if (borderLeft !== borderRight) {\n      top = borderTop;\n      bottom = borderBottom;\n    }\n    // not become a horizontal line?\n    if (borderTop !== borderBottom) {\n      left = borderLeft;\n      right = borderRight;\n    }\n  }\n\n  ctx.beginPath();\n  ctx.fillStyle = vm.backgroundColor;\n  ctx.strokeStyle = vm.borderColor;\n  ctx.lineWidth = borderWidth;\n\n  // Corner points, from bottom-left to bottom-right clockwise\n  // | 1 2 |\n  // | 0 3 |\n  const corners = [\n    [left, bottom],\n    [left, top],\n    [right, top],\n    [right, bottom]\n  ];\n\n  // Find first (starting) corner with fallback to 'bottom'\n  const borders = ['bottom', 'left', 'top', 'right'];\n  let startCorner = borders.indexOf(borderSkipped, 0);\n  if (startCorner === -1) {\n    startCorner = 0;\n  }\n\n  function cornerAt(index) {\n    return corners[(startCorner + index) % 4];\n  }\n\n  // Draw rectangle from 'startCorner'\n  let corner = cornerAt(0);\n  ctx.moveTo(corner[0], corner[1]);\n\n  for (let i = 1; i < 4; i += 1) {\n    corner = cornerAt(i);\n    let nextCornerId = i + 1;\n    if (nextCornerId === 4) {\n      nextCornerId = 0;\n    }\n\n    const width = corners[2][0] - corners[1][0];\n    const height = corners[0][1] - corners[1][1];\n    const x = corners[1][0];\n    const y = corners[1][1];\n\n    radius = cornerRadius;\n    // Fix radius being too large\n    if (radius > Math.abs(height) / 2) {\n      radius = Math.floor(Math.abs(height) / 2);\n    }\n    if (radius > Math.abs(width) / 2) {\n      radius = Math.floor(Math.abs(width) / 2);\n    }\n\n    if (height < 0) {\n      // Negative values in a standard bar chart\n      const xTl = x;\n      const xTr = x + width;\n      const yTl = y + height;\n      const yTr = y + height;\n\n      const xBl = x;\n      const xBr = x + width;\n      const yBl = y;\n      const yBr = y;\n\n      // Draw\n      ctx.moveTo(xBl + radius, yBl);\n      ctx.lineTo(xBr - radius, yBr);\n      ctx.quadraticCurveTo(xBr, yBr, xBr, yBr - radius);\n      ctx.lineTo(xTr, yTr + radius);\n      ctx.quadraticCurveTo(xTr, yTr, xTr - radius, yTr);\n      ctx.lineTo(xTl + radius, yTl);\n      ctx.quadraticCurveTo(xTl, yTl, xTl, yTl + radius);\n      ctx.lineTo(xBl, yBl - radius);\n      ctx.quadraticCurveTo(xBl, yBl, xBl + radius, yBl);\n    } else if (width < 0) {\n      // Negative values in a horizontal bar chart\n      const xTl = x + width;\n      const xTr = x;\n      const yTl = y;\n      const yTr = y;\n\n      const xBl = x + width;\n      const xBr = x;\n      const yBl = y + height;\n      const yBr = y + height;\n\n      // Draw\n      ctx.moveTo(xBl + radius, yBl);\n      ctx.lineTo(xBr - radius, yBr);\n      ctx.quadraticCurveTo(xBr, yBr, xBr, yBr - radius);\n      ctx.lineTo(xTr, yTr + radius);\n      ctx.quadraticCurveTo(xTr, yTr, xTr - radius, yTr);\n      ctx.lineTo(xTl + radius, yTl);\n      ctx.quadraticCurveTo(xTl, yTl, xTl, yTl + radius);\n      ctx.lineTo(xBl, yBl - radius);\n      ctx.quadraticCurveTo(xBl, yBl, xBl + radius, yBl);\n    } else {\n      // Positive Value\n      ctx.moveTo(x + radius, y);\n      ctx.lineTo(x + width - radius, y);\n      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n      ctx.lineTo(x + width, y + height - radius);\n      ctx.quadraticCurveTo(\n        x + width,\n        y + height,\n        x + width - radius,\n        y + height\n      );\n      ctx.lineTo(x + radius, y + height);\n      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n      ctx.lineTo(x, y + radius);\n      ctx.quadraticCurveTo(x, y, x + radius, y);\n    }\n  }\n\n  ctx.fill();\n  if (borderWidth) {\n    ctx.stroke();\n  }\n}\n\nChart.helpers.extend(Chart.elements.Rectangle.prototype, {\n  draw\n});\n"]},"metadata":{},"sourceType":"module"}